// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  TypedMap,
  Entity,
  Value,
  ValueKind,
  store,
  Bytes,
  BigInt,
  BigDecimal
} from "@graphprotocol/graph-ts";

export class DIDRegistryActedOnBehalf extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("_entityDid", Value.fromBytes(Bytes.empty()));
    this.set("_delegateAgentId", Value.fromBytes(Bytes.empty()));
    this.set("_responsibleAgentId", Value.fromBytes(Bytes.empty()));
    this.set("_activityId", Value.fromBytes(Bytes.empty()));
    this.set("provId", Value.fromBytes(Bytes.empty()));
    this.set("_attributes", Value.fromString(""));
    this.set("_blockNumberUpdated", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save DIDRegistryActedOnBehalf entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save DIDRegistryActedOnBehalf entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("DIDRegistryActedOnBehalf", id.toString(), this);
    }
  }

  static load(id: string): DIDRegistryActedOnBehalf | null {
    return changetype<DIDRegistryActedOnBehalf | null>(
      store.get("DIDRegistryActedOnBehalf", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get _entityDid(): Bytes {
    let value = this.get("_entityDid");
    return value!.toBytes();
  }

  set _entityDid(value: Bytes) {
    this.set("_entityDid", Value.fromBytes(value));
  }

  get _delegateAgentId(): Bytes {
    let value = this.get("_delegateAgentId");
    return value!.toBytes();
  }

  set _delegateAgentId(value: Bytes) {
    this.set("_delegateAgentId", Value.fromBytes(value));
  }

  get _responsibleAgentId(): Bytes {
    let value = this.get("_responsibleAgentId");
    return value!.toBytes();
  }

  set _responsibleAgentId(value: Bytes) {
    this.set("_responsibleAgentId", Value.fromBytes(value));
  }

  get _activityId(): Bytes {
    let value = this.get("_activityId");
    return value!.toBytes();
  }

  set _activityId(value: Bytes) {
    this.set("_activityId", Value.fromBytes(value));
  }

  get provId(): Bytes {
    let value = this.get("provId");
    return value!.toBytes();
  }

  set provId(value: Bytes) {
    this.set("provId", Value.fromBytes(value));
  }

  get _attributes(): string {
    let value = this.get("_attributes");
    return value!.toString();
  }

  set _attributes(value: string) {
    this.set("_attributes", Value.fromString(value));
  }

  get _blockNumberUpdated(): BigInt {
    let value = this.get("_blockNumberUpdated");
    return value!.toBigInt();
  }

  set _blockNumberUpdated(value: BigInt) {
    this.set("_blockNumberUpdated", Value.fromBigInt(value));
  }
}

export class DIDRegistryDIDAttributeRegistered extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("_did", Value.fromBytes(Bytes.empty()));
    this.set("_owner", Value.fromBytes(Bytes.empty()));
    this.set("_checksum", Value.fromBytes(Bytes.empty()));
    this.set("_value", Value.fromString(""));
    this.set("_lastUpdatedBy", Value.fromBytes(Bytes.empty()));
    this.set("_blockNumberUpdated", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save DIDRegistryDIDAttributeRegistered entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save DIDRegistryDIDAttributeRegistered entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("DIDRegistryDIDAttributeRegistered", id.toString(), this);
    }
  }

  static load(id: string): DIDRegistryDIDAttributeRegistered | null {
    return changetype<DIDRegistryDIDAttributeRegistered | null>(
      store.get("DIDRegistryDIDAttributeRegistered", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get _did(): Bytes {
    let value = this.get("_did");
    return value!.toBytes();
  }

  set _did(value: Bytes) {
    this.set("_did", Value.fromBytes(value));
  }

  get _owner(): Bytes {
    let value = this.get("_owner");
    return value!.toBytes();
  }

  set _owner(value: Bytes) {
    this.set("_owner", Value.fromBytes(value));
  }

  get _checksum(): Bytes {
    let value = this.get("_checksum");
    return value!.toBytes();
  }

  set _checksum(value: Bytes) {
    this.set("_checksum", Value.fromBytes(value));
  }

  get _value(): string {
    let value = this.get("_value");
    return value!.toString();
  }

  set _value(value: string) {
    this.set("_value", Value.fromString(value));
  }

  get _lastUpdatedBy(): Bytes {
    let value = this.get("_lastUpdatedBy");
    return value!.toBytes();
  }

  set _lastUpdatedBy(value: Bytes) {
    this.set("_lastUpdatedBy", Value.fromBytes(value));
  }

  get _blockNumberUpdated(): BigInt {
    let value = this.get("_blockNumberUpdated");
    return value!.toBigInt();
  }

  set _blockNumberUpdated(value: BigInt) {
    this.set("_blockNumberUpdated", Value.fromBigInt(value));
  }
}

export class DIDRegistryDIDOwnershipTransferred extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("_did", Value.fromBytes(Bytes.empty()));
    this.set("_previousOwner", Value.fromBytes(Bytes.empty()));
    this.set("_newOwner", Value.fromBytes(Bytes.empty()));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save DIDRegistryDIDOwnershipTransferred entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save DIDRegistryDIDOwnershipTransferred entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("DIDRegistryDIDOwnershipTransferred", id.toString(), this);
    }
  }

  static load(id: string): DIDRegistryDIDOwnershipTransferred | null {
    return changetype<DIDRegistryDIDOwnershipTransferred | null>(
      store.get("DIDRegistryDIDOwnershipTransferred", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get _did(): Bytes {
    let value = this.get("_did");
    return value!.toBytes();
  }

  set _did(value: Bytes) {
    this.set("_did", Value.fromBytes(value));
  }

  get _previousOwner(): Bytes {
    let value = this.get("_previousOwner");
    return value!.toBytes();
  }

  set _previousOwner(value: Bytes) {
    this.set("_previousOwner", Value.fromBytes(value));
  }

  get _newOwner(): Bytes {
    let value = this.get("_newOwner");
    return value!.toBytes();
  }

  set _newOwner(value: Bytes) {
    this.set("_newOwner", Value.fromBytes(value));
  }
}

export class DIDRegistryDIDPermissionGranted extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("_did", Value.fromBytes(Bytes.empty()));
    this.set("_owner", Value.fromBytes(Bytes.empty()));
    this.set("_grantee", Value.fromBytes(Bytes.empty()));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save DIDRegistryDIDPermissionGranted entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save DIDRegistryDIDPermissionGranted entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("DIDRegistryDIDPermissionGranted", id.toString(), this);
    }
  }

  static load(id: string): DIDRegistryDIDPermissionGranted | null {
    return changetype<DIDRegistryDIDPermissionGranted | null>(
      store.get("DIDRegistryDIDPermissionGranted", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get _did(): Bytes {
    let value = this.get("_did");
    return value!.toBytes();
  }

  set _did(value: Bytes) {
    this.set("_did", Value.fromBytes(value));
  }

  get _owner(): Bytes {
    let value = this.get("_owner");
    return value!.toBytes();
  }

  set _owner(value: Bytes) {
    this.set("_owner", Value.fromBytes(value));
  }

  get _grantee(): Bytes {
    let value = this.get("_grantee");
    return value!.toBytes();
  }

  set _grantee(value: Bytes) {
    this.set("_grantee", Value.fromBytes(value));
  }
}

export class DIDRegistryDIDPermissionRevoked extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("_did", Value.fromBytes(Bytes.empty()));
    this.set("_owner", Value.fromBytes(Bytes.empty()));
    this.set("_grantee", Value.fromBytes(Bytes.empty()));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save DIDRegistryDIDPermissionRevoked entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save DIDRegistryDIDPermissionRevoked entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("DIDRegistryDIDPermissionRevoked", id.toString(), this);
    }
  }

  static load(id: string): DIDRegistryDIDPermissionRevoked | null {
    return changetype<DIDRegistryDIDPermissionRevoked | null>(
      store.get("DIDRegistryDIDPermissionRevoked", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get _did(): Bytes {
    let value = this.get("_did");
    return value!.toBytes();
  }

  set _did(value: Bytes) {
    this.set("_did", Value.fromBytes(value));
  }

  get _owner(): Bytes {
    let value = this.get("_owner");
    return value!.toBytes();
  }

  set _owner(value: Bytes) {
    this.set("_owner", Value.fromBytes(value));
  }

  get _grantee(): Bytes {
    let value = this.get("_grantee");
    return value!.toBytes();
  }

  set _grantee(value: Bytes) {
    this.set("_grantee", Value.fromBytes(value));
  }
}

export class DIDRegistryDIDProvenanceDelegateAdded extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("_did", Value.fromBytes(Bytes.empty()));
    this.set("_delegate", Value.fromBytes(Bytes.empty()));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save DIDRegistryDIDProvenanceDelegateAdded entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save DIDRegistryDIDProvenanceDelegateAdded entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("DIDRegistryDIDProvenanceDelegateAdded", id.toString(), this);
    }
  }

  static load(id: string): DIDRegistryDIDProvenanceDelegateAdded | null {
    return changetype<DIDRegistryDIDProvenanceDelegateAdded | null>(
      store.get("DIDRegistryDIDProvenanceDelegateAdded", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get _did(): Bytes {
    let value = this.get("_did");
    return value!.toBytes();
  }

  set _did(value: Bytes) {
    this.set("_did", Value.fromBytes(value));
  }

  get _delegate(): Bytes {
    let value = this.get("_delegate");
    return value!.toBytes();
  }

  set _delegate(value: Bytes) {
    this.set("_delegate", Value.fromBytes(value));
  }
}

export class DIDRegistryDIDProvenanceDelegateRemoved extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("_did", Value.fromBytes(Bytes.empty()));
    this.set("_delegate", Value.fromBytes(Bytes.empty()));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save DIDRegistryDIDProvenanceDelegateRemoved entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save DIDRegistryDIDProvenanceDelegateRemoved entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("DIDRegistryDIDProvenanceDelegateRemoved", id.toString(), this);
    }
  }

  static load(id: string): DIDRegistryDIDProvenanceDelegateRemoved | null {
    return changetype<DIDRegistryDIDProvenanceDelegateRemoved | null>(
      store.get("DIDRegistryDIDProvenanceDelegateRemoved", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get _did(): Bytes {
    let value = this.get("_did");
    return value!.toBytes();
  }

  set _did(value: Bytes) {
    this.set("_did", Value.fromBytes(value));
  }

  get _delegate(): Bytes {
    let value = this.get("_delegate");
    return value!.toBytes();
  }

  set _delegate(value: Bytes) {
    this.set("_delegate", Value.fromBytes(value));
  }

  get state(): boolean {
    let value = this.get("state");
    return value!.toBoolean();
  }

  set state(value: boolean) {
    this.set("state", Value.fromBoolean(value));
  }
}

export class DIDRegistryDIDProviderAdded extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("_did", Value.fromBytes(Bytes.empty()));
    this.set("_provider", Value.fromBytes(Bytes.empty()));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save DIDRegistryDIDProviderAdded entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save DIDRegistryDIDProviderAdded entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("DIDRegistryDIDProviderAdded", id.toString(), this);
    }
  }

  static load(id: string): DIDRegistryDIDProviderAdded | null {
    return changetype<DIDRegistryDIDProviderAdded | null>(
      store.get("DIDRegistryDIDProviderAdded", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get _did(): Bytes {
    let value = this.get("_did");
    return value!.toBytes();
  }

  set _did(value: Bytes) {
    this.set("_did", Value.fromBytes(value));
  }

  get _provider(): Bytes {
    let value = this.get("_provider");
    return value!.toBytes();
  }

  set _provider(value: Bytes) {
    this.set("_provider", Value.fromBytes(value));
  }
}

export class DIDRegistryDIDProviderRemoved extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("_did", Value.fromBytes(Bytes.empty()));
    this.set("_provider", Value.fromBytes(Bytes.empty()));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save DIDRegistryDIDProviderRemoved entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save DIDRegistryDIDProviderRemoved entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("DIDRegistryDIDProviderRemoved", id.toString(), this);
    }
  }

  static load(id: string): DIDRegistryDIDProviderRemoved | null {
    return changetype<DIDRegistryDIDProviderRemoved | null>(
      store.get("DIDRegistryDIDProviderRemoved", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get _did(): Bytes {
    let value = this.get("_did");
    return value!.toBytes();
  }

  set _did(value: Bytes) {
    this.set("_did", Value.fromBytes(value));
  }

  get _provider(): Bytes {
    let value = this.get("_provider");
    return value!.toBytes();
  }

  set _provider(value: Bytes) {
    this.set("_provider", Value.fromBytes(value));
  }

  get state(): boolean {
    let value = this.get("state");
    return value!.toBoolean();
  }

  set state(value: boolean) {
    this.set("state", Value.fromBoolean(value));
  }
}

export class DIDRegistryInitialized extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save DIDRegistryInitialized entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save DIDRegistryInitialized entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("DIDRegistryInitialized", id.toString(), this);
    }
  }

  static load(id: string): DIDRegistryInitialized | null {
    return changetype<DIDRegistryInitialized | null>(
      store.get("DIDRegistryInitialized", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get version(): i32 {
    let value = this.get("version");
    return value!.toI32();
  }

  set version(value: i32) {
    this.set("version", Value.fromI32(value));
  }
}

export class DIDRegistryOwnershipTransferred extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("previousOwner", Value.fromBytes(Bytes.empty()));
    this.set("newOwner", Value.fromBytes(Bytes.empty()));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save DIDRegistryOwnershipTransferred entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save DIDRegistryOwnershipTransferred entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("DIDRegistryOwnershipTransferred", id.toString(), this);
    }
  }

  static load(id: string): DIDRegistryOwnershipTransferred | null {
    return changetype<DIDRegistryOwnershipTransferred | null>(
      store.get("DIDRegistryOwnershipTransferred", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get previousOwner(): Bytes {
    let value = this.get("previousOwner");
    return value!.toBytes();
  }

  set previousOwner(value: Bytes) {
    this.set("previousOwner", Value.fromBytes(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value!.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class DIDRegistryProvenanceAttributeRegistered extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("provId", Value.fromBytes(Bytes.empty()));
    this.set("_did", Value.fromBytes(Bytes.empty()));
    this.set("_agentId", Value.fromBytes(Bytes.empty()));
    this.set("_activityId", Value.fromBytes(Bytes.empty()));
    this.set("_relatedDid", Value.fromBytes(Bytes.empty()));
    this.set("_agentInvolvedId", Value.fromBytes(Bytes.empty()));
    this.set("_attributes", Value.fromString(""));
    this.set("_blockNumberUpdated", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save DIDRegistryProvenanceAttributeRegistered entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save DIDRegistryProvenanceAttributeRegistered entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set(
        "DIDRegistryProvenanceAttributeRegistered",
        id.toString(),
        this
      );
    }
  }

  static load(id: string): DIDRegistryProvenanceAttributeRegistered | null {
    return changetype<DIDRegistryProvenanceAttributeRegistered | null>(
      store.get("DIDRegistryProvenanceAttributeRegistered", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get provId(): Bytes {
    let value = this.get("provId");
    return value!.toBytes();
  }

  set provId(value: Bytes) {
    this.set("provId", Value.fromBytes(value));
  }

  get _did(): Bytes {
    let value = this.get("_did");
    return value!.toBytes();
  }

  set _did(value: Bytes) {
    this.set("_did", Value.fromBytes(value));
  }

  get _agentId(): Bytes {
    let value = this.get("_agentId");
    return value!.toBytes();
  }

  set _agentId(value: Bytes) {
    this.set("_agentId", Value.fromBytes(value));
  }

  get _activityId(): Bytes {
    let value = this.get("_activityId");
    return value!.toBytes();
  }

  set _activityId(value: Bytes) {
    this.set("_activityId", Value.fromBytes(value));
  }

  get _relatedDid(): Bytes {
    let value = this.get("_relatedDid");
    return value!.toBytes();
  }

  set _relatedDid(value: Bytes) {
    this.set("_relatedDid", Value.fromBytes(value));
  }

  get _agentInvolvedId(): Bytes {
    let value = this.get("_agentInvolvedId");
    return value!.toBytes();
  }

  set _agentInvolvedId(value: Bytes) {
    this.set("_agentInvolvedId", Value.fromBytes(value));
  }

  get _method(): i32 {
    let value = this.get("_method");
    return value!.toI32();
  }

  set _method(value: i32) {
    this.set("_method", Value.fromI32(value));
  }

  get _attributes(): string {
    let value = this.get("_attributes");
    return value!.toString();
  }

  set _attributes(value: string) {
    this.set("_attributes", Value.fromString(value));
  }

  get _blockNumberUpdated(): BigInt {
    let value = this.get("_blockNumberUpdated");
    return value!.toBigInt();
  }

  set _blockNumberUpdated(value: BigInt) {
    this.set("_blockNumberUpdated", Value.fromBigInt(value));
  }
}

export class DIDRegistryUsed extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("_did", Value.fromBytes(Bytes.empty()));
    this.set("_agentId", Value.fromBytes(Bytes.empty()));
    this.set("_activityId", Value.fromBytes(Bytes.empty()));
    this.set("provId", Value.fromBytes(Bytes.empty()));
    this.set("_attributes", Value.fromString(""));
    this.set("_blockNumberUpdated", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save DIDRegistryUsed entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save DIDRegistryUsed entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("DIDRegistryUsed", id.toString(), this);
    }
  }

  static load(id: string): DIDRegistryUsed | null {
    return changetype<DIDRegistryUsed | null>(store.get("DIDRegistryUsed", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get _did(): Bytes {
    let value = this.get("_did");
    return value!.toBytes();
  }

  set _did(value: Bytes) {
    this.set("_did", Value.fromBytes(value));
  }

  get _agentId(): Bytes {
    let value = this.get("_agentId");
    return value!.toBytes();
  }

  set _agentId(value: Bytes) {
    this.set("_agentId", Value.fromBytes(value));
  }

  get _activityId(): Bytes {
    let value = this.get("_activityId");
    return value!.toBytes();
  }

  set _activityId(value: Bytes) {
    this.set("_activityId", Value.fromBytes(value));
  }

  get provId(): Bytes {
    let value = this.get("provId");
    return value!.toBytes();
  }

  set provId(value: Bytes) {
    this.set("provId", Value.fromBytes(value));
  }

  get _attributes(): string {
    let value = this.get("_attributes");
    return value!.toString();
  }

  set _attributes(value: string) {
    this.set("_attributes", Value.fromString(value));
  }

  get _blockNumberUpdated(): BigInt {
    let value = this.get("_blockNumberUpdated");
    return value!.toBigInt();
  }

  set _blockNumberUpdated(value: BigInt) {
    this.set("_blockNumberUpdated", Value.fromBigInt(value));
  }
}

export class DIDRegistryWasAssociatedWith extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("_entityDid", Value.fromBytes(Bytes.empty()));
    this.set("_agentId", Value.fromBytes(Bytes.empty()));
    this.set("_activityId", Value.fromBytes(Bytes.empty()));
    this.set("provId", Value.fromBytes(Bytes.empty()));
    this.set("_attributes", Value.fromString(""));
    this.set("_blockNumberUpdated", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save DIDRegistryWasAssociatedWith entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save DIDRegistryWasAssociatedWith entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("DIDRegistryWasAssociatedWith", id.toString(), this);
    }
  }

  static load(id: string): DIDRegistryWasAssociatedWith | null {
    return changetype<DIDRegistryWasAssociatedWith | null>(
      store.get("DIDRegistryWasAssociatedWith", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get _entityDid(): Bytes {
    let value = this.get("_entityDid");
    return value!.toBytes();
  }

  set _entityDid(value: Bytes) {
    this.set("_entityDid", Value.fromBytes(value));
  }

  get _agentId(): Bytes {
    let value = this.get("_agentId");
    return value!.toBytes();
  }

  set _agentId(value: Bytes) {
    this.set("_agentId", Value.fromBytes(value));
  }

  get _activityId(): Bytes {
    let value = this.get("_activityId");
    return value!.toBytes();
  }

  set _activityId(value: Bytes) {
    this.set("_activityId", Value.fromBytes(value));
  }

  get provId(): Bytes {
    let value = this.get("provId");
    return value!.toBytes();
  }

  set provId(value: Bytes) {
    this.set("provId", Value.fromBytes(value));
  }

  get _attributes(): string {
    let value = this.get("_attributes");
    return value!.toString();
  }

  set _attributes(value: string) {
    this.set("_attributes", Value.fromString(value));
  }

  get _blockNumberUpdated(): BigInt {
    let value = this.get("_blockNumberUpdated");
    return value!.toBigInt();
  }

  set _blockNumberUpdated(value: BigInt) {
    this.set("_blockNumberUpdated", Value.fromBigInt(value));
  }
}

export class DIDRegistryWasDerivedFrom extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("_newEntityDid", Value.fromBytes(Bytes.empty()));
    this.set("_usedEntityDid", Value.fromBytes(Bytes.empty()));
    this.set("_agentId", Value.fromBytes(Bytes.empty()));
    this.set("_activityId", Value.fromBytes(Bytes.empty()));
    this.set("provId", Value.fromBytes(Bytes.empty()));
    this.set("_attributes", Value.fromString(""));
    this.set("_blockNumberUpdated", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save DIDRegistryWasDerivedFrom entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save DIDRegistryWasDerivedFrom entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("DIDRegistryWasDerivedFrom", id.toString(), this);
    }
  }

  static load(id: string): DIDRegistryWasDerivedFrom | null {
    return changetype<DIDRegistryWasDerivedFrom | null>(
      store.get("DIDRegistryWasDerivedFrom", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get _newEntityDid(): Bytes {
    let value = this.get("_newEntityDid");
    return value!.toBytes();
  }

  set _newEntityDid(value: Bytes) {
    this.set("_newEntityDid", Value.fromBytes(value));
  }

  get _usedEntityDid(): Bytes {
    let value = this.get("_usedEntityDid");
    return value!.toBytes();
  }

  set _usedEntityDid(value: Bytes) {
    this.set("_usedEntityDid", Value.fromBytes(value));
  }

  get _agentId(): Bytes {
    let value = this.get("_agentId");
    return value!.toBytes();
  }

  set _agentId(value: Bytes) {
    this.set("_agentId", Value.fromBytes(value));
  }

  get _activityId(): Bytes {
    let value = this.get("_activityId");
    return value!.toBytes();
  }

  set _activityId(value: Bytes) {
    this.set("_activityId", Value.fromBytes(value));
  }

  get provId(): Bytes {
    let value = this.get("provId");
    return value!.toBytes();
  }

  set provId(value: Bytes) {
    this.set("provId", Value.fromBytes(value));
  }

  get _attributes(): string {
    let value = this.get("_attributes");
    return value!.toString();
  }

  set _attributes(value: string) {
    this.set("_attributes", Value.fromString(value));
  }

  get _blockNumberUpdated(): BigInt {
    let value = this.get("_blockNumberUpdated");
    return value!.toBigInt();
  }

  set _blockNumberUpdated(value: BigInt) {
    this.set("_blockNumberUpdated", Value.fromBigInt(value));
  }
}

export class DIDRegistryWasGeneratedBy extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("_did", Value.fromBytes(Bytes.empty()));
    this.set("_agentId", Value.fromBytes(Bytes.empty()));
    this.set("_activityId", Value.fromBytes(Bytes.empty()));
    this.set("provId", Value.fromBytes(Bytes.empty()));
    this.set("_attributes", Value.fromString(""));
    this.set("_blockNumberUpdated", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save DIDRegistryWasGeneratedBy entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save DIDRegistryWasGeneratedBy entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("DIDRegistryWasGeneratedBy", id.toString(), this);
    }
  }

  static load(id: string): DIDRegistryWasGeneratedBy | null {
    return changetype<DIDRegistryWasGeneratedBy | null>(
      store.get("DIDRegistryWasGeneratedBy", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get _did(): Bytes {
    let value = this.get("_did");
    return value!.toBytes();
  }

  set _did(value: Bytes) {
    this.set("_did", Value.fromBytes(value));
  }

  get _agentId(): Bytes {
    let value = this.get("_agentId");
    return value!.toBytes();
  }

  set _agentId(value: Bytes) {
    this.set("_agentId", Value.fromBytes(value));
  }

  get _activityId(): Bytes {
    let value = this.get("_activityId");
    return value!.toBytes();
  }

  set _activityId(value: Bytes) {
    this.set("_activityId", Value.fromBytes(value));
  }

  get provId(): Bytes {
    let value = this.get("provId");
    return value!.toBytes();
  }

  set provId(value: Bytes) {
    this.set("provId", Value.fromBytes(value));
  }

  get _attributes(): string {
    let value = this.get("_attributes");
    return value!.toString();
  }

  set _attributes(value: string) {
    this.set("_attributes", Value.fromString(value));
  }

  get _blockNumberUpdated(): BigInt {
    let value = this.get("_blockNumberUpdated");
    return value!.toBigInt();
  }

  set _blockNumberUpdated(value: BigInt) {
    this.set("_blockNumberUpdated", Value.fromBigInt(value));
  }
}

export class NeverminedConfigInitialized extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save NeverminedConfigInitialized entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save NeverminedConfigInitialized entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("NeverminedConfigInitialized", id.toString(), this);
    }
  }

  static load(id: string): NeverminedConfigInitialized | null {
    return changetype<NeverminedConfigInitialized | null>(
      store.get("NeverminedConfigInitialized", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get version(): i32 {
    let value = this.get("version");
    return value!.toI32();
  }

  set version(value: i32) {
    this.set("version", Value.fromI32(value));
  }
}

export class NeverminedConfigNeverminedConfigChange extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("_whoChanged", Value.fromBytes(Bytes.empty()));
    this.set("_parameter", Value.fromBytes(Bytes.empty()));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save NeverminedConfigNeverminedConfigChange entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save NeverminedConfigNeverminedConfigChange entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("NeverminedConfigNeverminedConfigChange", id.toString(), this);
    }
  }

  static load(id: string): NeverminedConfigNeverminedConfigChange | null {
    return changetype<NeverminedConfigNeverminedConfigChange | null>(
      store.get("NeverminedConfigNeverminedConfigChange", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get _whoChanged(): Bytes {
    let value = this.get("_whoChanged");
    return value!.toBytes();
  }

  set _whoChanged(value: Bytes) {
    this.set("_whoChanged", Value.fromBytes(value));
  }

  get _parameter(): Bytes {
    let value = this.get("_parameter");
    return value!.toBytes();
  }

  set _parameter(value: Bytes) {
    this.set("_parameter", Value.fromBytes(value));
  }
}

export class NeverminedConfigOwnershipTransferred extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("previousOwner", Value.fromBytes(Bytes.empty()));
    this.set("newOwner", Value.fromBytes(Bytes.empty()));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save NeverminedConfigOwnershipTransferred entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save NeverminedConfigOwnershipTransferred entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("NeverminedConfigOwnershipTransferred", id.toString(), this);
    }
  }

  static load(id: string): NeverminedConfigOwnershipTransferred | null {
    return changetype<NeverminedConfigOwnershipTransferred | null>(
      store.get("NeverminedConfigOwnershipTransferred", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get previousOwner(): Bytes {
    let value = this.get("previousOwner");
    return value!.toBytes();
  }

  set previousOwner(value: Bytes) {
    this.set("previousOwner", Value.fromBytes(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value!.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class NeverminedConfigRoleAdminChanged extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("role", Value.fromBytes(Bytes.empty()));
    this.set("previousAdminRole", Value.fromBytes(Bytes.empty()));
    this.set("newAdminRole", Value.fromBytes(Bytes.empty()));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save NeverminedConfigRoleAdminChanged entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save NeverminedConfigRoleAdminChanged entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("NeverminedConfigRoleAdminChanged", id.toString(), this);
    }
  }

  static load(id: string): NeverminedConfigRoleAdminChanged | null {
    return changetype<NeverminedConfigRoleAdminChanged | null>(
      store.get("NeverminedConfigRoleAdminChanged", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get role(): Bytes {
    let value = this.get("role");
    return value!.toBytes();
  }

  set role(value: Bytes) {
    this.set("role", Value.fromBytes(value));
  }

  get previousAdminRole(): Bytes {
    let value = this.get("previousAdminRole");
    return value!.toBytes();
  }

  set previousAdminRole(value: Bytes) {
    this.set("previousAdminRole", Value.fromBytes(value));
  }

  get newAdminRole(): Bytes {
    let value = this.get("newAdminRole");
    return value!.toBytes();
  }

  set newAdminRole(value: Bytes) {
    this.set("newAdminRole", Value.fromBytes(value));
  }
}

export class NeverminedConfigRoleGranted extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("role", Value.fromBytes(Bytes.empty()));
    this.set("account", Value.fromBytes(Bytes.empty()));
    this.set("sender", Value.fromBytes(Bytes.empty()));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save NeverminedConfigRoleGranted entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save NeverminedConfigRoleGranted entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("NeverminedConfigRoleGranted", id.toString(), this);
    }
  }

  static load(id: string): NeverminedConfigRoleGranted | null {
    return changetype<NeverminedConfigRoleGranted | null>(
      store.get("NeverminedConfigRoleGranted", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get role(): Bytes {
    let value = this.get("role");
    return value!.toBytes();
  }

  set role(value: Bytes) {
    this.set("role", Value.fromBytes(value));
  }

  get account(): Bytes {
    let value = this.get("account");
    return value!.toBytes();
  }

  set account(value: Bytes) {
    this.set("account", Value.fromBytes(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    return value!.toBytes();
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }
}

export class NeverminedConfigRoleRevoked extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("role", Value.fromBytes(Bytes.empty()));
    this.set("account", Value.fromBytes(Bytes.empty()));
    this.set("sender", Value.fromBytes(Bytes.empty()));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save NeverminedConfigRoleRevoked entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save NeverminedConfigRoleRevoked entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("NeverminedConfigRoleRevoked", id.toString(), this);
    }
  }

  static load(id: string): NeverminedConfigRoleRevoked | null {
    return changetype<NeverminedConfigRoleRevoked | null>(
      store.get("NeverminedConfigRoleRevoked", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get role(): Bytes {
    let value = this.get("role");
    return value!.toBytes();
  }

  set role(value: Bytes) {
    this.set("role", Value.fromBytes(value));
  }

  get account(): Bytes {
    let value = this.get("account");
    return value!.toBytes();
  }

  set account(value: Bytes) {
    this.set("account", Value.fromBytes(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    return value!.toBytes();
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }
}

export class NFT721AccessProofTemplateAgreementCreated extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("_agreementId", Value.fromBytes(Bytes.empty()));
    this.set("_did", Value.fromBytes(Bytes.empty()));
    this.set("_accessConsumer", Value.fromBytes(Bytes.empty()));
    this.set("_accessProvider", Value.fromBytes(Bytes.empty()));
    this.set("_timeLocks", Value.fromBigIntArray(new Array(0)));
    this.set("_timeOuts", Value.fromBigIntArray(new Array(0)));
    this.set("_conditionIdSeeds", Value.fromBytesArray(new Array(0)));
    this.set("_conditionIds", Value.fromBytesArray(new Array(0)));
    this.set("_idSeed", Value.fromBytes(Bytes.empty()));
    this.set("_creator", Value.fromBytes(Bytes.empty()));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save NFT721AccessProofTemplateAgreementCreated entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save NFT721AccessProofTemplateAgreementCreated entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set(
        "NFT721AccessProofTemplateAgreementCreated",
        id.toString(),
        this
      );
    }
  }

  static load(id: string): NFT721AccessProofTemplateAgreementCreated | null {
    return changetype<NFT721AccessProofTemplateAgreementCreated | null>(
      store.get("NFT721AccessProofTemplateAgreementCreated", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get _agreementId(): Bytes {
    let value = this.get("_agreementId");
    return value!.toBytes();
  }

  set _agreementId(value: Bytes) {
    this.set("_agreementId", Value.fromBytes(value));
  }

  get _did(): Bytes {
    let value = this.get("_did");
    return value!.toBytes();
  }

  set _did(value: Bytes) {
    this.set("_did", Value.fromBytes(value));
  }

  get _accessConsumer(): Bytes {
    let value = this.get("_accessConsumer");
    return value!.toBytes();
  }

  set _accessConsumer(value: Bytes) {
    this.set("_accessConsumer", Value.fromBytes(value));
  }

  get _accessProvider(): Bytes {
    let value = this.get("_accessProvider");
    return value!.toBytes();
  }

  set _accessProvider(value: Bytes) {
    this.set("_accessProvider", Value.fromBytes(value));
  }

  get _timeLocks(): Array<BigInt> {
    let value = this.get("_timeLocks");
    return value!.toBigIntArray();
  }

  set _timeLocks(value: Array<BigInt>) {
    this.set("_timeLocks", Value.fromBigIntArray(value));
  }

  get _timeOuts(): Array<BigInt> {
    let value = this.get("_timeOuts");
    return value!.toBigIntArray();
  }

  set _timeOuts(value: Array<BigInt>) {
    this.set("_timeOuts", Value.fromBigIntArray(value));
  }

  get _conditionIdSeeds(): Array<Bytes> {
    let value = this.get("_conditionIdSeeds");
    return value!.toBytesArray();
  }

  set _conditionIdSeeds(value: Array<Bytes>) {
    this.set("_conditionIdSeeds", Value.fromBytesArray(value));
  }

  get _conditionIds(): Array<Bytes> {
    let value = this.get("_conditionIds");
    return value!.toBytesArray();
  }

  set _conditionIds(value: Array<Bytes>) {
    this.set("_conditionIds", Value.fromBytesArray(value));
  }

  get _idSeed(): Bytes {
    let value = this.get("_idSeed");
    return value!.toBytes();
  }

  set _idSeed(value: Bytes) {
    this.set("_idSeed", Value.fromBytes(value));
  }

  get _creator(): Bytes {
    let value = this.get("_creator");
    return value!.toBytes();
  }

  set _creator(value: Bytes) {
    this.set("_creator", Value.fromBytes(value));
  }
}

export class NFT721AccessProofTemplateInitialized extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save NFT721AccessProofTemplateInitialized entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save NFT721AccessProofTemplateInitialized entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("NFT721AccessProofTemplateInitialized", id.toString(), this);
    }
  }

  static load(id: string): NFT721AccessProofTemplateInitialized | null {
    return changetype<NFT721AccessProofTemplateInitialized | null>(
      store.get("NFT721AccessProofTemplateInitialized", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get version(): i32 {
    let value = this.get("version");
    return value!.toI32();
  }

  set version(value: i32) {
    this.set("version", Value.fromI32(value));
  }
}

export class NFT721AccessProofTemplateOwnershipTransferred extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("previousOwner", Value.fromBytes(Bytes.empty()));
    this.set("newOwner", Value.fromBytes(Bytes.empty()));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save NFT721AccessProofTemplateOwnershipTransferred entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save NFT721AccessProofTemplateOwnershipTransferred entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set(
        "NFT721AccessProofTemplateOwnershipTransferred",
        id.toString(),
        this
      );
    }
  }

  static load(
    id: string
  ): NFT721AccessProofTemplateOwnershipTransferred | null {
    return changetype<NFT721AccessProofTemplateOwnershipTransferred | null>(
      store.get("NFT721AccessProofTemplateOwnershipTransferred", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get previousOwner(): Bytes {
    let value = this.get("previousOwner");
    return value!.toBytes();
  }

  set previousOwner(value: Bytes) {
    this.set("previousOwner", Value.fromBytes(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value!.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class NFT721AccessSwapTemplateAgreementCreated extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("_agreementId", Value.fromBytes(Bytes.empty()));
    this.set("_did", Value.fromBytes(Bytes.empty()));
    this.set("_accessConsumer", Value.fromBytes(Bytes.empty()));
    this.set("_accessProvider", Value.fromBytes(Bytes.empty()));
    this.set("_timeLocks", Value.fromBigIntArray(new Array(0)));
    this.set("_timeOuts", Value.fromBigIntArray(new Array(0)));
    this.set("_conditionIdSeeds", Value.fromBytesArray(new Array(0)));
    this.set("_conditionIds", Value.fromBytesArray(new Array(0)));
    this.set("_idSeed", Value.fromBytes(Bytes.empty()));
    this.set("_creator", Value.fromBytes(Bytes.empty()));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save NFT721AccessSwapTemplateAgreementCreated entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save NFT721AccessSwapTemplateAgreementCreated entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set(
        "NFT721AccessSwapTemplateAgreementCreated",
        id.toString(),
        this
      );
    }
  }

  static load(id: string): NFT721AccessSwapTemplateAgreementCreated | null {
    return changetype<NFT721AccessSwapTemplateAgreementCreated | null>(
      store.get("NFT721AccessSwapTemplateAgreementCreated", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get _agreementId(): Bytes {
    let value = this.get("_agreementId");
    return value!.toBytes();
  }

  set _agreementId(value: Bytes) {
    this.set("_agreementId", Value.fromBytes(value));
  }

  get _did(): Bytes {
    let value = this.get("_did");
    return value!.toBytes();
  }

  set _did(value: Bytes) {
    this.set("_did", Value.fromBytes(value));
  }

  get _accessConsumer(): Bytes {
    let value = this.get("_accessConsumer");
    return value!.toBytes();
  }

  set _accessConsumer(value: Bytes) {
    this.set("_accessConsumer", Value.fromBytes(value));
  }

  get _accessProvider(): Bytes {
    let value = this.get("_accessProvider");
    return value!.toBytes();
  }

  set _accessProvider(value: Bytes) {
    this.set("_accessProvider", Value.fromBytes(value));
  }

  get _timeLocks(): Array<BigInt> {
    let value = this.get("_timeLocks");
    return value!.toBigIntArray();
  }

  set _timeLocks(value: Array<BigInt>) {
    this.set("_timeLocks", Value.fromBigIntArray(value));
  }

  get _timeOuts(): Array<BigInt> {
    let value = this.get("_timeOuts");
    return value!.toBigIntArray();
  }

  set _timeOuts(value: Array<BigInt>) {
    this.set("_timeOuts", Value.fromBigIntArray(value));
  }

  get _conditionIdSeeds(): Array<Bytes> {
    let value = this.get("_conditionIdSeeds");
    return value!.toBytesArray();
  }

  set _conditionIdSeeds(value: Array<Bytes>) {
    this.set("_conditionIdSeeds", Value.fromBytesArray(value));
  }

  get _conditionIds(): Array<Bytes> {
    let value = this.get("_conditionIds");
    return value!.toBytesArray();
  }

  set _conditionIds(value: Array<Bytes>) {
    this.set("_conditionIds", Value.fromBytesArray(value));
  }

  get _idSeed(): Bytes {
    let value = this.get("_idSeed");
    return value!.toBytes();
  }

  set _idSeed(value: Bytes) {
    this.set("_idSeed", Value.fromBytes(value));
  }

  get _creator(): Bytes {
    let value = this.get("_creator");
    return value!.toBytes();
  }

  set _creator(value: Bytes) {
    this.set("_creator", Value.fromBytes(value));
  }
}

export class NFT721AccessSwapTemplateInitialized extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save NFT721AccessSwapTemplateInitialized entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save NFT721AccessSwapTemplateInitialized entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("NFT721AccessSwapTemplateInitialized", id.toString(), this);
    }
  }

  static load(id: string): NFT721AccessSwapTemplateInitialized | null {
    return changetype<NFT721AccessSwapTemplateInitialized | null>(
      store.get("NFT721AccessSwapTemplateInitialized", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get version(): i32 {
    let value = this.get("version");
    return value!.toI32();
  }

  set version(value: i32) {
    this.set("version", Value.fromI32(value));
  }
}

export class NFT721AccessSwapTemplateOwnershipTransferred extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("previousOwner", Value.fromBytes(Bytes.empty()));
    this.set("newOwner", Value.fromBytes(Bytes.empty()));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save NFT721AccessSwapTemplateOwnershipTransferred entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save NFT721AccessSwapTemplateOwnershipTransferred entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set(
        "NFT721AccessSwapTemplateOwnershipTransferred",
        id.toString(),
        this
      );
    }
  }

  static load(id: string): NFT721AccessSwapTemplateOwnershipTransferred | null {
    return changetype<NFT721AccessSwapTemplateOwnershipTransferred | null>(
      store.get("NFT721AccessSwapTemplateOwnershipTransferred", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get previousOwner(): Bytes {
    let value = this.get("previousOwner");
    return value!.toBytes();
  }

  set previousOwner(value: Bytes) {
    this.set("previousOwner", Value.fromBytes(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value!.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class NFT721EscrowPaymentConditionFulfilled extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("_agreementId", Value.fromBytes(Bytes.empty()));
    this.set("_tokenAddress", Value.fromBytes(Bytes.empty()));
    this.set("_did", Value.fromBytes(Bytes.empty()));
    this.set("_receivers", Value.fromBytes(Bytes.empty()));
    this.set("_conditionId", Value.fromBytes(Bytes.empty()));
    this.set("_amounts", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save NFT721EscrowPaymentConditionFulfilled entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save NFT721EscrowPaymentConditionFulfilled entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("NFT721EscrowPaymentConditionFulfilled", id.toString(), this);
    }
  }

  static load(id: string): NFT721EscrowPaymentConditionFulfilled | null {
    return changetype<NFT721EscrowPaymentConditionFulfilled | null>(
      store.get("NFT721EscrowPaymentConditionFulfilled", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get _agreementId(): Bytes {
    let value = this.get("_agreementId");
    return value!.toBytes();
  }

  set _agreementId(value: Bytes) {
    this.set("_agreementId", Value.fromBytes(value));
  }

  get _tokenAddress(): Bytes {
    let value = this.get("_tokenAddress");
    return value!.toBytes();
  }

  set _tokenAddress(value: Bytes) {
    this.set("_tokenAddress", Value.fromBytes(value));
  }

  get _did(): Bytes {
    let value = this.get("_did");
    return value!.toBytes();
  }

  set _did(value: Bytes) {
    this.set("_did", Value.fromBytes(value));
  }

  get _receivers(): Bytes {
    let value = this.get("_receivers");
    return value!.toBytes();
  }

  set _receivers(value: Bytes) {
    this.set("_receivers", Value.fromBytes(value));
  }

  get _conditionId(): Bytes {
    let value = this.get("_conditionId");
    return value!.toBytes();
  }

  set _conditionId(value: Bytes) {
    this.set("_conditionId", Value.fromBytes(value));
  }

  get _amounts(): BigInt {
    let value = this.get("_amounts");
    return value!.toBigInt();
  }

  set _amounts(value: BigInt) {
    this.set("_amounts", Value.fromBigInt(value));
  }
}

export class NFT721EscrowPaymentConditionInitialized extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save NFT721EscrowPaymentConditionInitialized entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save NFT721EscrowPaymentConditionInitialized entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("NFT721EscrowPaymentConditionInitialized", id.toString(), this);
    }
  }

  static load(id: string): NFT721EscrowPaymentConditionInitialized | null {
    return changetype<NFT721EscrowPaymentConditionInitialized | null>(
      store.get("NFT721EscrowPaymentConditionInitialized", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get version(): i32 {
    let value = this.get("version");
    return value!.toI32();
  }

  set version(value: i32) {
    this.set("version", Value.fromI32(value));
  }
}

export class NFT721EscrowPaymentConditionOwnershipTransferred extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("previousOwner", Value.fromBytes(Bytes.empty()));
    this.set("newOwner", Value.fromBytes(Bytes.empty()));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save NFT721EscrowPaymentConditionOwnershipTransferred entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save NFT721EscrowPaymentConditionOwnershipTransferred entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set(
        "NFT721EscrowPaymentConditionOwnershipTransferred",
        id.toString(),
        this
      );
    }
  }

  static load(
    id: string
  ): NFT721EscrowPaymentConditionOwnershipTransferred | null {
    return changetype<NFT721EscrowPaymentConditionOwnershipTransferred | null>(
      store.get("NFT721EscrowPaymentConditionOwnershipTransferred", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get previousOwner(): Bytes {
    let value = this.get("previousOwner");
    return value!.toBytes();
  }

  set previousOwner(value: Bytes) {
    this.set("previousOwner", Value.fromBytes(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value!.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class NFT721EscrowPaymentConditionReceived extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("_from", Value.fromBytes(Bytes.empty()));
    this.set("_value", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save NFT721EscrowPaymentConditionReceived entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save NFT721EscrowPaymentConditionReceived entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("NFT721EscrowPaymentConditionReceived", id.toString(), this);
    }
  }

  static load(id: string): NFT721EscrowPaymentConditionReceived | null {
    return changetype<NFT721EscrowPaymentConditionReceived | null>(
      store.get("NFT721EscrowPaymentConditionReceived", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get _from(): Bytes {
    let value = this.get("_from");
    return value!.toBytes();
  }

  set _from(value: Bytes) {
    this.set("_from", Value.fromBytes(value));
  }

  get _value(): BigInt {
    let value = this.get("_value");
    return value!.toBigInt();
  }

  set _value(value: BigInt) {
    this.set("_value", Value.fromBigInt(value));
  }
}

export class NFT721SalesWithAccessTemplateAgreementCreated extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("_agreementId", Value.fromBytes(Bytes.empty()));
    this.set("_did", Value.fromBytes(Bytes.empty()));
    this.set("_accessConsumer", Value.fromBytes(Bytes.empty()));
    this.set("_accessProvider", Value.fromBytes(Bytes.empty()));
    this.set("_timeLocks", Value.fromBigIntArray(new Array(0)));
    this.set("_timeOuts", Value.fromBigIntArray(new Array(0)));
    this.set("_conditionIdSeeds", Value.fromBytesArray(new Array(0)));
    this.set("_conditionIds", Value.fromBytesArray(new Array(0)));
    this.set("_idSeed", Value.fromBytes(Bytes.empty()));
    this.set("_creator", Value.fromBytes(Bytes.empty()));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save NFT721SalesWithAccessTemplateAgreementCreated entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save NFT721SalesWithAccessTemplateAgreementCreated entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set(
        "NFT721SalesWithAccessTemplateAgreementCreated",
        id.toString(),
        this
      );
    }
  }

  static load(
    id: string
  ): NFT721SalesWithAccessTemplateAgreementCreated | null {
    return changetype<NFT721SalesWithAccessTemplateAgreementCreated | null>(
      store.get("NFT721SalesWithAccessTemplateAgreementCreated", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get _agreementId(): Bytes {
    let value = this.get("_agreementId");
    return value!.toBytes();
  }

  set _agreementId(value: Bytes) {
    this.set("_agreementId", Value.fromBytes(value));
  }

  get _did(): Bytes {
    let value = this.get("_did");
    return value!.toBytes();
  }

  set _did(value: Bytes) {
    this.set("_did", Value.fromBytes(value));
  }

  get _accessConsumer(): Bytes {
    let value = this.get("_accessConsumer");
    return value!.toBytes();
  }

  set _accessConsumer(value: Bytes) {
    this.set("_accessConsumer", Value.fromBytes(value));
  }

  get _accessProvider(): Bytes {
    let value = this.get("_accessProvider");
    return value!.toBytes();
  }

  set _accessProvider(value: Bytes) {
    this.set("_accessProvider", Value.fromBytes(value));
  }

  get _timeLocks(): Array<BigInt> {
    let value = this.get("_timeLocks");
    return value!.toBigIntArray();
  }

  set _timeLocks(value: Array<BigInt>) {
    this.set("_timeLocks", Value.fromBigIntArray(value));
  }

  get _timeOuts(): Array<BigInt> {
    let value = this.get("_timeOuts");
    return value!.toBigIntArray();
  }

  set _timeOuts(value: Array<BigInt>) {
    this.set("_timeOuts", Value.fromBigIntArray(value));
  }

  get _conditionIdSeeds(): Array<Bytes> {
    let value = this.get("_conditionIdSeeds");
    return value!.toBytesArray();
  }

  set _conditionIdSeeds(value: Array<Bytes>) {
    this.set("_conditionIdSeeds", Value.fromBytesArray(value));
  }

  get _conditionIds(): Array<Bytes> {
    let value = this.get("_conditionIds");
    return value!.toBytesArray();
  }

  set _conditionIds(value: Array<Bytes>) {
    this.set("_conditionIds", Value.fromBytesArray(value));
  }

  get _idSeed(): Bytes {
    let value = this.get("_idSeed");
    return value!.toBytes();
  }

  set _idSeed(value: Bytes) {
    this.set("_idSeed", Value.fromBytes(value));
  }

  get _creator(): Bytes {
    let value = this.get("_creator");
    return value!.toBytes();
  }

  set _creator(value: Bytes) {
    this.set("_creator", Value.fromBytes(value));
  }
}

export class NFT721SalesWithAccessTemplateInitialized extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save NFT721SalesWithAccessTemplateInitialized entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save NFT721SalesWithAccessTemplateInitialized entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set(
        "NFT721SalesWithAccessTemplateInitialized",
        id.toString(),
        this
      );
    }
  }

  static load(id: string): NFT721SalesWithAccessTemplateInitialized | null {
    return changetype<NFT721SalesWithAccessTemplateInitialized | null>(
      store.get("NFT721SalesWithAccessTemplateInitialized", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get version(): i32 {
    let value = this.get("version");
    return value!.toI32();
  }

  set version(value: i32) {
    this.set("version", Value.fromI32(value));
  }
}

export class NFT721SalesWithAccessTemplateOwnershipTransferred extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("previousOwner", Value.fromBytes(Bytes.empty()));
    this.set("newOwner", Value.fromBytes(Bytes.empty()));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save NFT721SalesWithAccessTemplateOwnershipTransferred entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save NFT721SalesWithAccessTemplateOwnershipTransferred entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set(
        "NFT721SalesWithAccessTemplateOwnershipTransferred",
        id.toString(),
        this
      );
    }
  }

  static load(
    id: string
  ): NFT721SalesWithAccessTemplateOwnershipTransferred | null {
    return changetype<NFT721SalesWithAccessTemplateOwnershipTransferred | null>(
      store.get("NFT721SalesWithAccessTemplateOwnershipTransferred", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get previousOwner(): Bytes {
    let value = this.get("previousOwner");
    return value!.toBytes();
  }

  set previousOwner(value: Bytes) {
    this.set("previousOwner", Value.fromBytes(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value!.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class NFTAccessProofTemplateAgreementCreated extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("_agreementId", Value.fromBytes(Bytes.empty()));
    this.set("_did", Value.fromBytes(Bytes.empty()));
    this.set("_accessConsumer", Value.fromBytes(Bytes.empty()));
    this.set("_accessProvider", Value.fromBytes(Bytes.empty()));
    this.set("_timeLocks", Value.fromBigIntArray(new Array(0)));
    this.set("_timeOuts", Value.fromBigIntArray(new Array(0)));
    this.set("_conditionIdSeeds", Value.fromBytesArray(new Array(0)));
    this.set("_conditionIds", Value.fromBytesArray(new Array(0)));
    this.set("_idSeed", Value.fromBytes(Bytes.empty()));
    this.set("_creator", Value.fromBytes(Bytes.empty()));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save NFTAccessProofTemplateAgreementCreated entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save NFTAccessProofTemplateAgreementCreated entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("NFTAccessProofTemplateAgreementCreated", id.toString(), this);
    }
  }

  static load(id: string): NFTAccessProofTemplateAgreementCreated | null {
    return changetype<NFTAccessProofTemplateAgreementCreated | null>(
      store.get("NFTAccessProofTemplateAgreementCreated", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get _agreementId(): Bytes {
    let value = this.get("_agreementId");
    return value!.toBytes();
  }

  set _agreementId(value: Bytes) {
    this.set("_agreementId", Value.fromBytes(value));
  }

  get _did(): Bytes {
    let value = this.get("_did");
    return value!.toBytes();
  }

  set _did(value: Bytes) {
    this.set("_did", Value.fromBytes(value));
  }

  get _accessConsumer(): Bytes {
    let value = this.get("_accessConsumer");
    return value!.toBytes();
  }

  set _accessConsumer(value: Bytes) {
    this.set("_accessConsumer", Value.fromBytes(value));
  }

  get _accessProvider(): Bytes {
    let value = this.get("_accessProvider");
    return value!.toBytes();
  }

  set _accessProvider(value: Bytes) {
    this.set("_accessProvider", Value.fromBytes(value));
  }

  get _timeLocks(): Array<BigInt> {
    let value = this.get("_timeLocks");
    return value!.toBigIntArray();
  }

  set _timeLocks(value: Array<BigInt>) {
    this.set("_timeLocks", Value.fromBigIntArray(value));
  }

  get _timeOuts(): Array<BigInt> {
    let value = this.get("_timeOuts");
    return value!.toBigIntArray();
  }

  set _timeOuts(value: Array<BigInt>) {
    this.set("_timeOuts", Value.fromBigIntArray(value));
  }

  get _conditionIdSeeds(): Array<Bytes> {
    let value = this.get("_conditionIdSeeds");
    return value!.toBytesArray();
  }

  set _conditionIdSeeds(value: Array<Bytes>) {
    this.set("_conditionIdSeeds", Value.fromBytesArray(value));
  }

  get _conditionIds(): Array<Bytes> {
    let value = this.get("_conditionIds");
    return value!.toBytesArray();
  }

  set _conditionIds(value: Array<Bytes>) {
    this.set("_conditionIds", Value.fromBytesArray(value));
  }

  get _idSeed(): Bytes {
    let value = this.get("_idSeed");
    return value!.toBytes();
  }

  set _idSeed(value: Bytes) {
    this.set("_idSeed", Value.fromBytes(value));
  }

  get _creator(): Bytes {
    let value = this.get("_creator");
    return value!.toBytes();
  }

  set _creator(value: Bytes) {
    this.set("_creator", Value.fromBytes(value));
  }
}

export class NFTAccessProofTemplateInitialized extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save NFTAccessProofTemplateInitialized entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save NFTAccessProofTemplateInitialized entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("NFTAccessProofTemplateInitialized", id.toString(), this);
    }
  }

  static load(id: string): NFTAccessProofTemplateInitialized | null {
    return changetype<NFTAccessProofTemplateInitialized | null>(
      store.get("NFTAccessProofTemplateInitialized", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get version(): i32 {
    let value = this.get("version");
    return value!.toI32();
  }

  set version(value: i32) {
    this.set("version", Value.fromI32(value));
  }
}

export class NFTAccessProofTemplateOwnershipTransferred extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("previousOwner", Value.fromBytes(Bytes.empty()));
    this.set("newOwner", Value.fromBytes(Bytes.empty()));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save NFTAccessProofTemplateOwnershipTransferred entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save NFTAccessProofTemplateOwnershipTransferred entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set(
        "NFTAccessProofTemplateOwnershipTransferred",
        id.toString(),
        this
      );
    }
  }

  static load(id: string): NFTAccessProofTemplateOwnershipTransferred | null {
    return changetype<NFTAccessProofTemplateOwnershipTransferred | null>(
      store.get("NFTAccessProofTemplateOwnershipTransferred", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get previousOwner(): Bytes {
    let value = this.get("previousOwner");
    return value!.toBytes();
  }

  set previousOwner(value: Bytes) {
    this.set("previousOwner", Value.fromBytes(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value!.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class NFTAccessSwapTemplateAgreementCreated extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("_agreementId", Value.fromBytes(Bytes.empty()));
    this.set("_did", Value.fromBytes(Bytes.empty()));
    this.set("_accessConsumer", Value.fromBytes(Bytes.empty()));
    this.set("_accessProvider", Value.fromBytes(Bytes.empty()));
    this.set("_timeLocks", Value.fromBigIntArray(new Array(0)));
    this.set("_timeOuts", Value.fromBigIntArray(new Array(0)));
    this.set("_conditionIdSeeds", Value.fromBytesArray(new Array(0)));
    this.set("_conditionIds", Value.fromBytesArray(new Array(0)));
    this.set("_idSeed", Value.fromBytes(Bytes.empty()));
    this.set("_creator", Value.fromBytes(Bytes.empty()));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save NFTAccessSwapTemplateAgreementCreated entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save NFTAccessSwapTemplateAgreementCreated entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("NFTAccessSwapTemplateAgreementCreated", id.toString(), this);
    }
  }

  static load(id: string): NFTAccessSwapTemplateAgreementCreated | null {
    return changetype<NFTAccessSwapTemplateAgreementCreated | null>(
      store.get("NFTAccessSwapTemplateAgreementCreated", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get _agreementId(): Bytes {
    let value = this.get("_agreementId");
    return value!.toBytes();
  }

  set _agreementId(value: Bytes) {
    this.set("_agreementId", Value.fromBytes(value));
  }

  get _did(): Bytes {
    let value = this.get("_did");
    return value!.toBytes();
  }

  set _did(value: Bytes) {
    this.set("_did", Value.fromBytes(value));
  }

  get _accessConsumer(): Bytes {
    let value = this.get("_accessConsumer");
    return value!.toBytes();
  }

  set _accessConsumer(value: Bytes) {
    this.set("_accessConsumer", Value.fromBytes(value));
  }

  get _accessProvider(): Bytes {
    let value = this.get("_accessProvider");
    return value!.toBytes();
  }

  set _accessProvider(value: Bytes) {
    this.set("_accessProvider", Value.fromBytes(value));
  }

  get _timeLocks(): Array<BigInt> {
    let value = this.get("_timeLocks");
    return value!.toBigIntArray();
  }

  set _timeLocks(value: Array<BigInt>) {
    this.set("_timeLocks", Value.fromBigIntArray(value));
  }

  get _timeOuts(): Array<BigInt> {
    let value = this.get("_timeOuts");
    return value!.toBigIntArray();
  }

  set _timeOuts(value: Array<BigInt>) {
    this.set("_timeOuts", Value.fromBigIntArray(value));
  }

  get _conditionIdSeeds(): Array<Bytes> {
    let value = this.get("_conditionIdSeeds");
    return value!.toBytesArray();
  }

  set _conditionIdSeeds(value: Array<Bytes>) {
    this.set("_conditionIdSeeds", Value.fromBytesArray(value));
  }

  get _conditionIds(): Array<Bytes> {
    let value = this.get("_conditionIds");
    return value!.toBytesArray();
  }

  set _conditionIds(value: Array<Bytes>) {
    this.set("_conditionIds", Value.fromBytesArray(value));
  }

  get _idSeed(): Bytes {
    let value = this.get("_idSeed");
    return value!.toBytes();
  }

  set _idSeed(value: Bytes) {
    this.set("_idSeed", Value.fromBytes(value));
  }

  get _creator(): Bytes {
    let value = this.get("_creator");
    return value!.toBytes();
  }

  set _creator(value: Bytes) {
    this.set("_creator", Value.fromBytes(value));
  }
}

export class NFTAccessSwapTemplateInitialized extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save NFTAccessSwapTemplateInitialized entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save NFTAccessSwapTemplateInitialized entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("NFTAccessSwapTemplateInitialized", id.toString(), this);
    }
  }

  static load(id: string): NFTAccessSwapTemplateInitialized | null {
    return changetype<NFTAccessSwapTemplateInitialized | null>(
      store.get("NFTAccessSwapTemplateInitialized", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get version(): i32 {
    let value = this.get("version");
    return value!.toI32();
  }

  set version(value: i32) {
    this.set("version", Value.fromI32(value));
  }
}

export class NFTAccessSwapTemplateOwnershipTransferred extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("previousOwner", Value.fromBytes(Bytes.empty()));
    this.set("newOwner", Value.fromBytes(Bytes.empty()));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save NFTAccessSwapTemplateOwnershipTransferred entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save NFTAccessSwapTemplateOwnershipTransferred entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set(
        "NFTAccessSwapTemplateOwnershipTransferred",
        id.toString(),
        this
      );
    }
  }

  static load(id: string): NFTAccessSwapTemplateOwnershipTransferred | null {
    return changetype<NFTAccessSwapTemplateOwnershipTransferred | null>(
      store.get("NFTAccessSwapTemplateOwnershipTransferred", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get previousOwner(): Bytes {
    let value = this.get("previousOwner");
    return value!.toBytes();
  }

  set previousOwner(value: Bytes) {
    this.set("previousOwner", Value.fromBytes(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value!.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class NFTEscrowPaymentConditionFulfilled extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("_agreementId", Value.fromBytes(Bytes.empty()));
    this.set("_tokenAddress", Value.fromBytes(Bytes.empty()));
    this.set("_did", Value.fromBytes(Bytes.empty()));
    this.set("_receivers", Value.fromBytes(Bytes.empty()));
    this.set("_conditionId", Value.fromBytes(Bytes.empty()));
    this.set("_amounts", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save NFTEscrowPaymentConditionFulfilled entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save NFTEscrowPaymentConditionFulfilled entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("NFTEscrowPaymentConditionFulfilled", id.toString(), this);
    }
  }

  static load(id: string): NFTEscrowPaymentConditionFulfilled | null {
    return changetype<NFTEscrowPaymentConditionFulfilled | null>(
      store.get("NFTEscrowPaymentConditionFulfilled", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get _agreementId(): Bytes {
    let value = this.get("_agreementId");
    return value!.toBytes();
  }

  set _agreementId(value: Bytes) {
    this.set("_agreementId", Value.fromBytes(value));
  }

  get _tokenAddress(): Bytes {
    let value = this.get("_tokenAddress");
    return value!.toBytes();
  }

  set _tokenAddress(value: Bytes) {
    this.set("_tokenAddress", Value.fromBytes(value));
  }

  get _did(): Bytes {
    let value = this.get("_did");
    return value!.toBytes();
  }

  set _did(value: Bytes) {
    this.set("_did", Value.fromBytes(value));
  }

  get _receivers(): Bytes {
    let value = this.get("_receivers");
    return value!.toBytes();
  }

  set _receivers(value: Bytes) {
    this.set("_receivers", Value.fromBytes(value));
  }

  get _conditionId(): Bytes {
    let value = this.get("_conditionId");
    return value!.toBytes();
  }

  set _conditionId(value: Bytes) {
    this.set("_conditionId", Value.fromBytes(value));
  }

  get _amounts(): BigInt {
    let value = this.get("_amounts");
    return value!.toBigInt();
  }

  set _amounts(value: BigInt) {
    this.set("_amounts", Value.fromBigInt(value));
  }
}

export class NFTEscrowPaymentConditionInitialized extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save NFTEscrowPaymentConditionInitialized entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save NFTEscrowPaymentConditionInitialized entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("NFTEscrowPaymentConditionInitialized", id.toString(), this);
    }
  }

  static load(id: string): NFTEscrowPaymentConditionInitialized | null {
    return changetype<NFTEscrowPaymentConditionInitialized | null>(
      store.get("NFTEscrowPaymentConditionInitialized", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get version(): i32 {
    let value = this.get("version");
    return value!.toI32();
  }

  set version(value: i32) {
    this.set("version", Value.fromI32(value));
  }
}

export class NFTEscrowPaymentConditionOwnershipTransferred extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("previousOwner", Value.fromBytes(Bytes.empty()));
    this.set("newOwner", Value.fromBytes(Bytes.empty()));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save NFTEscrowPaymentConditionOwnershipTransferred entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save NFTEscrowPaymentConditionOwnershipTransferred entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set(
        "NFTEscrowPaymentConditionOwnershipTransferred",
        id.toString(),
        this
      );
    }
  }

  static load(
    id: string
  ): NFTEscrowPaymentConditionOwnershipTransferred | null {
    return changetype<NFTEscrowPaymentConditionOwnershipTransferred | null>(
      store.get("NFTEscrowPaymentConditionOwnershipTransferred", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get previousOwner(): Bytes {
    let value = this.get("previousOwner");
    return value!.toBytes();
  }

  set previousOwner(value: Bytes) {
    this.set("previousOwner", Value.fromBytes(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value!.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class NFTEscrowPaymentConditionReceived extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("_from", Value.fromBytes(Bytes.empty()));
    this.set("_value", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save NFTEscrowPaymentConditionReceived entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save NFTEscrowPaymentConditionReceived entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("NFTEscrowPaymentConditionReceived", id.toString(), this);
    }
  }

  static load(id: string): NFTEscrowPaymentConditionReceived | null {
    return changetype<NFTEscrowPaymentConditionReceived | null>(
      store.get("NFTEscrowPaymentConditionReceived", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get _from(): Bytes {
    let value = this.get("_from");
    return value!.toBytes();
  }

  set _from(value: Bytes) {
    this.set("_from", Value.fromBytes(value));
  }

  get _value(): BigInt {
    let value = this.get("_value");
    return value!.toBigInt();
  }

  set _value(value: BigInt) {
    this.set("_value", Value.fromBigInt(value));
  }
}

export class NFTSalesWithAccessTemplateAgreementCreated extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("_agreementId", Value.fromBytes(Bytes.empty()));
    this.set("_did", Value.fromBytes(Bytes.empty()));
    this.set("_accessConsumer", Value.fromBytes(Bytes.empty()));
    this.set("_accessProvider", Value.fromBytes(Bytes.empty()));
    this.set("_timeLocks", Value.fromBigIntArray(new Array(0)));
    this.set("_timeOuts", Value.fromBigIntArray(new Array(0)));
    this.set("_conditionIdSeeds", Value.fromBytesArray(new Array(0)));
    this.set("_conditionIds", Value.fromBytesArray(new Array(0)));
    this.set("_idSeed", Value.fromBytes(Bytes.empty()));
    this.set("_creator", Value.fromBytes(Bytes.empty()));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save NFTSalesWithAccessTemplateAgreementCreated entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save NFTSalesWithAccessTemplateAgreementCreated entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set(
        "NFTSalesWithAccessTemplateAgreementCreated",
        id.toString(),
        this
      );
    }
  }

  static load(id: string): NFTSalesWithAccessTemplateAgreementCreated | null {
    return changetype<NFTSalesWithAccessTemplateAgreementCreated | null>(
      store.get("NFTSalesWithAccessTemplateAgreementCreated", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get _agreementId(): Bytes {
    let value = this.get("_agreementId");
    return value!.toBytes();
  }

  set _agreementId(value: Bytes) {
    this.set("_agreementId", Value.fromBytes(value));
  }

  get _did(): Bytes {
    let value = this.get("_did");
    return value!.toBytes();
  }

  set _did(value: Bytes) {
    this.set("_did", Value.fromBytes(value));
  }

  get _accessConsumer(): Bytes {
    let value = this.get("_accessConsumer");
    return value!.toBytes();
  }

  set _accessConsumer(value: Bytes) {
    this.set("_accessConsumer", Value.fromBytes(value));
  }

  get _accessProvider(): Bytes {
    let value = this.get("_accessProvider");
    return value!.toBytes();
  }

  set _accessProvider(value: Bytes) {
    this.set("_accessProvider", Value.fromBytes(value));
  }

  get _timeLocks(): Array<BigInt> {
    let value = this.get("_timeLocks");
    return value!.toBigIntArray();
  }

  set _timeLocks(value: Array<BigInt>) {
    this.set("_timeLocks", Value.fromBigIntArray(value));
  }

  get _timeOuts(): Array<BigInt> {
    let value = this.get("_timeOuts");
    return value!.toBigIntArray();
  }

  set _timeOuts(value: Array<BigInt>) {
    this.set("_timeOuts", Value.fromBigIntArray(value));
  }

  get _conditionIdSeeds(): Array<Bytes> {
    let value = this.get("_conditionIdSeeds");
    return value!.toBytesArray();
  }

  set _conditionIdSeeds(value: Array<Bytes>) {
    this.set("_conditionIdSeeds", Value.fromBytesArray(value));
  }

  get _conditionIds(): Array<Bytes> {
    let value = this.get("_conditionIds");
    return value!.toBytesArray();
  }

  set _conditionIds(value: Array<Bytes>) {
    this.set("_conditionIds", Value.fromBytesArray(value));
  }

  get _idSeed(): Bytes {
    let value = this.get("_idSeed");
    return value!.toBytes();
  }

  set _idSeed(value: Bytes) {
    this.set("_idSeed", Value.fromBytes(value));
  }

  get _creator(): Bytes {
    let value = this.get("_creator");
    return value!.toBytes();
  }

  set _creator(value: Bytes) {
    this.set("_creator", Value.fromBytes(value));
  }
}

export class NFTSalesWithAccessTemplateInitialized extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save NFTSalesWithAccessTemplateInitialized entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save NFTSalesWithAccessTemplateInitialized entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("NFTSalesWithAccessTemplateInitialized", id.toString(), this);
    }
  }

  static load(id: string): NFTSalesWithAccessTemplateInitialized | null {
    return changetype<NFTSalesWithAccessTemplateInitialized | null>(
      store.get("NFTSalesWithAccessTemplateInitialized", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get version(): i32 {
    let value = this.get("version");
    return value!.toI32();
  }

  set version(value: i32) {
    this.set("version", Value.fromI32(value));
  }
}

export class NFTSalesWithAccessTemplateOwnershipTransferred extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("previousOwner", Value.fromBytes(Bytes.empty()));
    this.set("newOwner", Value.fromBytes(Bytes.empty()));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save NFTSalesWithAccessTemplateOwnershipTransferred entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save NFTSalesWithAccessTemplateOwnershipTransferred entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set(
        "NFTSalesWithAccessTemplateOwnershipTransferred",
        id.toString(),
        this
      );
    }
  }

  static load(
    id: string
  ): NFTSalesWithAccessTemplateOwnershipTransferred | null {
    return changetype<NFTSalesWithAccessTemplateOwnershipTransferred | null>(
      store.get("NFTSalesWithAccessTemplateOwnershipTransferred", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get previousOwner(): Bytes {
    let value = this.get("previousOwner");
    return value!.toBytes();
  }

  set previousOwner(value: Bytes) {
    this.set("previousOwner", Value.fromBytes(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value!.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}
